// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/auroraride/adapter/model"
	"github.com/auroraride/cabservd/internal/ent/bin"
	"github.com/auroraride/cabservd/internal/ent/cabinet"
	"github.com/auroraride/cabservd/internal/ent/console"
	"github.com/auroraride/cabservd/internal/ent/predicate"
	"github.com/auroraride/cabservd/internal/ent/scan"
	"github.com/auroraride/cabservd/internal/types"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBin     = "Bin"
	TypeCabinet = "Cabinet"
	TypeConsole = "Console"
	TypeScan    = "Scan"
)

// BinMutation represents an operation that mutates the Bin nodes in the graph.
type BinMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	uuid           *string
	brand          *string
	serial         *string
	name           *string
	ordinal        *int
	addordinal     *int
	open           *bool
	enable         *bool
	health         *bool
	battery_exists *bool
	battery_sn     *string
	voltage        *float64
	addvoltage     *float64
	current        *float64
	addcurrent     *float64
	soc            *float64
	addsoc         *float64
	soh            *float64
	addsoh         *float64
	remark         *string
	clearedFields  map[string]struct{}
	cabinet        *uint64
	clearedcabinet bool
	done           bool
	oldValue       func(context.Context) (*Bin, error)
	predicates     []predicate.Bin
}

var _ ent.Mutation = (*BinMutation)(nil)

// binOption allows management of the mutation configuration using functional options.
type binOption func(*BinMutation)

// newBinMutation creates new mutation for the Bin entity.
func newBinMutation(c config, op Op, opts ...binOption) *BinMutation {
	m := &BinMutation{
		config:        c,
		op:            op,
		typ:           TypeBin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBinID sets the ID field of the mutation.
func withBinID(id uint64) binOption {
	return func(m *BinMutation) {
		var (
			err   error
			once  sync.Once
			value *Bin
		)
		m.oldValue = func(ctx context.Context) (*Bin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBin sets the old Bin of the mutation.
func withBin(node *Bin) binOption {
	return func(m *BinMutation) {
		m.oldValue = func(context.Context) (*Bin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BinMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BinMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BinMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BinMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BinMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BinMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BinMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BinMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUUID sets the "uuid" field.
func (m *BinMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *BinMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *BinMutation) ResetUUID() {
	m.uuid = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *BinMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *BinMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *BinMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetBrand sets the "brand" field.
func (m *BinMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *BinMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *BinMutation) ResetBrand() {
	m.brand = nil
}

// SetSerial sets the "serial" field.
func (m *BinMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *BinMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *BinMutation) ResetSerial() {
	m.serial = nil
}

// SetName sets the "name" field.
func (m *BinMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BinMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BinMutation) ResetName() {
	m.name = nil
}

// SetOrdinal sets the "ordinal" field.
func (m *BinMutation) SetOrdinal(i int) {
	m.ordinal = &i
	m.addordinal = nil
}

// Ordinal returns the value of the "ordinal" field in the mutation.
func (m *BinMutation) Ordinal() (r int, exists bool) {
	v := m.ordinal
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdinal returns the old "ordinal" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldOrdinal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdinal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdinal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdinal: %w", err)
	}
	return oldValue.Ordinal, nil
}

// AddOrdinal adds i to the "ordinal" field.
func (m *BinMutation) AddOrdinal(i int) {
	if m.addordinal != nil {
		*m.addordinal += i
	} else {
		m.addordinal = &i
	}
}

// AddedOrdinal returns the value that was added to the "ordinal" field in this mutation.
func (m *BinMutation) AddedOrdinal() (r int, exists bool) {
	v := m.addordinal
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrdinal resets all changes to the "ordinal" field.
func (m *BinMutation) ResetOrdinal() {
	m.ordinal = nil
	m.addordinal = nil
}

// SetOpen sets the "open" field.
func (m *BinMutation) SetOpen(b bool) {
	m.open = &b
}

// Open returns the value of the "open" field in the mutation.
func (m *BinMutation) Open() (r bool, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// ResetOpen resets all changes to the "open" field.
func (m *BinMutation) ResetOpen() {
	m.open = nil
}

// SetEnable sets the "enable" field.
func (m *BinMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *BinMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *BinMutation) ResetEnable() {
	m.enable = nil
}

// SetHealth sets the "health" field.
func (m *BinMutation) SetHealth(b bool) {
	m.health = &b
}

// Health returns the value of the "health" field in the mutation.
func (m *BinMutation) Health() (r bool, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old "health" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldHealth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// ResetHealth resets all changes to the "health" field.
func (m *BinMutation) ResetHealth() {
	m.health = nil
}

// SetBatteryExists sets the "battery_exists" field.
func (m *BinMutation) SetBatteryExists(b bool) {
	m.battery_exists = &b
}

// BatteryExists returns the value of the "battery_exists" field in the mutation.
func (m *BinMutation) BatteryExists() (r bool, exists bool) {
	v := m.battery_exists
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryExists returns the old "battery_exists" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldBatteryExists(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryExists is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryExists requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryExists: %w", err)
	}
	return oldValue.BatteryExists, nil
}

// ResetBatteryExists resets all changes to the "battery_exists" field.
func (m *BinMutation) ResetBatteryExists() {
	m.battery_exists = nil
}

// SetBatterySn sets the "battery_sn" field.
func (m *BinMutation) SetBatterySn(s string) {
	m.battery_sn = &s
}

// BatterySn returns the value of the "battery_sn" field in the mutation.
func (m *BinMutation) BatterySn() (r string, exists bool) {
	v := m.battery_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldBatterySn returns the old "battery_sn" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldBatterySn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatterySn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatterySn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatterySn: %w", err)
	}
	return oldValue.BatterySn, nil
}

// ResetBatterySn resets all changes to the "battery_sn" field.
func (m *BinMutation) ResetBatterySn() {
	m.battery_sn = nil
}

// SetVoltage sets the "voltage" field.
func (m *BinMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *BinMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *BinMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *BinMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *BinMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// SetCurrent sets the "current" field.
func (m *BinMutation) SetCurrent(f float64) {
	m.current = &f
	m.addcurrent = nil
}

// Current returns the value of the "current" field in the mutation.
func (m *BinMutation) Current() (r float64, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldCurrent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// AddCurrent adds f to the "current" field.
func (m *BinMutation) AddCurrent(f float64) {
	if m.addcurrent != nil {
		*m.addcurrent += f
	} else {
		m.addcurrent = &f
	}
}

// AddedCurrent returns the value that was added to the "current" field in this mutation.
func (m *BinMutation) AddedCurrent() (r float64, exists bool) {
	v := m.addcurrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrent resets all changes to the "current" field.
func (m *BinMutation) ResetCurrent() {
	m.current = nil
	m.addcurrent = nil
}

// SetSoc sets the "soc" field.
func (m *BinMutation) SetSoc(f float64) {
	m.soc = &f
	m.addsoc = nil
}

// Soc returns the value of the "soc" field in the mutation.
func (m *BinMutation) Soc() (r float64, exists bool) {
	v := m.soc
	if v == nil {
		return
	}
	return *v, true
}

// OldSoc returns the old "soc" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldSoc(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoc: %w", err)
	}
	return oldValue.Soc, nil
}

// AddSoc adds f to the "soc" field.
func (m *BinMutation) AddSoc(f float64) {
	if m.addsoc != nil {
		*m.addsoc += f
	} else {
		m.addsoc = &f
	}
}

// AddedSoc returns the value that was added to the "soc" field in this mutation.
func (m *BinMutation) AddedSoc() (r float64, exists bool) {
	v := m.addsoc
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoc resets all changes to the "soc" field.
func (m *BinMutation) ResetSoc() {
	m.soc = nil
	m.addsoc = nil
}

// SetSoh sets the "soh" field.
func (m *BinMutation) SetSoh(f float64) {
	m.soh = &f
	m.addsoh = nil
}

// Soh returns the value of the "soh" field in the mutation.
func (m *BinMutation) Soh() (r float64, exists bool) {
	v := m.soh
	if v == nil {
		return
	}
	return *v, true
}

// OldSoh returns the old "soh" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldSoh(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoh: %w", err)
	}
	return oldValue.Soh, nil
}

// AddSoh adds f to the "soh" field.
func (m *BinMutation) AddSoh(f float64) {
	if m.addsoh != nil {
		*m.addsoh += f
	} else {
		m.addsoh = &f
	}
}

// AddedSoh returns the value that was added to the "soh" field in this mutation.
func (m *BinMutation) AddedSoh() (r float64, exists bool) {
	v := m.addsoh
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoh resets all changes to the "soh" field.
func (m *BinMutation) ResetSoh() {
	m.soh = nil
	m.addsoh = nil
}

// SetRemark sets the "remark" field.
func (m *BinMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BinMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Bin entity.
// If the Bin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BinMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BinMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[bin.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BinMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[bin.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BinMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, bin.FieldRemark)
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *BinMutation) ClearCabinet() {
	m.clearedcabinet = true
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *BinMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *BinMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *BinMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// Where appends a list predicates to the BinMutation builder.
func (m *BinMutation) Where(ps ...predicate.Bin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bin).
func (m *BinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BinMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, bin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bin.FieldUpdatedAt)
	}
	if m.uuid != nil {
		fields = append(fields, bin.FieldUUID)
	}
	if m.cabinet != nil {
		fields = append(fields, bin.FieldCabinetID)
	}
	if m.brand != nil {
		fields = append(fields, bin.FieldBrand)
	}
	if m.serial != nil {
		fields = append(fields, bin.FieldSerial)
	}
	if m.name != nil {
		fields = append(fields, bin.FieldName)
	}
	if m.ordinal != nil {
		fields = append(fields, bin.FieldOrdinal)
	}
	if m.open != nil {
		fields = append(fields, bin.FieldOpen)
	}
	if m.enable != nil {
		fields = append(fields, bin.FieldEnable)
	}
	if m.health != nil {
		fields = append(fields, bin.FieldHealth)
	}
	if m.battery_exists != nil {
		fields = append(fields, bin.FieldBatteryExists)
	}
	if m.battery_sn != nil {
		fields = append(fields, bin.FieldBatterySn)
	}
	if m.voltage != nil {
		fields = append(fields, bin.FieldVoltage)
	}
	if m.current != nil {
		fields = append(fields, bin.FieldCurrent)
	}
	if m.soc != nil {
		fields = append(fields, bin.FieldSoc)
	}
	if m.soh != nil {
		fields = append(fields, bin.FieldSoh)
	}
	if m.remark != nil {
		fields = append(fields, bin.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bin.FieldCreatedAt:
		return m.CreatedAt()
	case bin.FieldUpdatedAt:
		return m.UpdatedAt()
	case bin.FieldUUID:
		return m.UUID()
	case bin.FieldCabinetID:
		return m.CabinetID()
	case bin.FieldBrand:
		return m.Brand()
	case bin.FieldSerial:
		return m.Serial()
	case bin.FieldName:
		return m.Name()
	case bin.FieldOrdinal:
		return m.Ordinal()
	case bin.FieldOpen:
		return m.Open()
	case bin.FieldEnable:
		return m.Enable()
	case bin.FieldHealth:
		return m.Health()
	case bin.FieldBatteryExists:
		return m.BatteryExists()
	case bin.FieldBatterySn:
		return m.BatterySn()
	case bin.FieldVoltage:
		return m.Voltage()
	case bin.FieldCurrent:
		return m.Current()
	case bin.FieldSoc:
		return m.Soc()
	case bin.FieldSoh:
		return m.Soh()
	case bin.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bin.FieldUUID:
		return m.OldUUID(ctx)
	case bin.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case bin.FieldBrand:
		return m.OldBrand(ctx)
	case bin.FieldSerial:
		return m.OldSerial(ctx)
	case bin.FieldName:
		return m.OldName(ctx)
	case bin.FieldOrdinal:
		return m.OldOrdinal(ctx)
	case bin.FieldOpen:
		return m.OldOpen(ctx)
	case bin.FieldEnable:
		return m.OldEnable(ctx)
	case bin.FieldHealth:
		return m.OldHealth(ctx)
	case bin.FieldBatteryExists:
		return m.OldBatteryExists(ctx)
	case bin.FieldBatterySn:
		return m.OldBatterySn(ctx)
	case bin.FieldVoltage:
		return m.OldVoltage(ctx)
	case bin.FieldCurrent:
		return m.OldCurrent(ctx)
	case bin.FieldSoc:
		return m.OldSoc(ctx)
	case bin.FieldSoh:
		return m.OldSoh(ctx)
	case bin.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Bin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bin.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case bin.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case bin.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case bin.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case bin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bin.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdinal(v)
		return nil
	case bin.FieldOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case bin.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case bin.FieldHealth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	case bin.FieldBatteryExists:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryExists(v)
		return nil
	case bin.FieldBatterySn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatterySn(v)
		return nil
	case bin.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case bin.FieldCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case bin.FieldSoc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoc(v)
		return nil
	case bin.FieldSoh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoh(v)
		return nil
	case bin.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Bin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BinMutation) AddedFields() []string {
	var fields []string
	if m.addordinal != nil {
		fields = append(fields, bin.FieldOrdinal)
	}
	if m.addvoltage != nil {
		fields = append(fields, bin.FieldVoltage)
	}
	if m.addcurrent != nil {
		fields = append(fields, bin.FieldCurrent)
	}
	if m.addsoc != nil {
		fields = append(fields, bin.FieldSoc)
	}
	if m.addsoh != nil {
		fields = append(fields, bin.FieldSoh)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bin.FieldOrdinal:
		return m.AddedOrdinal()
	case bin.FieldVoltage:
		return m.AddedVoltage()
	case bin.FieldCurrent:
		return m.AddedCurrent()
	case bin.FieldSoc:
		return m.AddedSoc()
	case bin.FieldSoh:
		return m.AddedSoh()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BinMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bin.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrdinal(v)
		return nil
	case bin.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case bin.FieldCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrent(v)
		return nil
	case bin.FieldSoc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoc(v)
		return nil
	case bin.FieldSoh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoh(v)
		return nil
	}
	return fmt.Errorf("unknown Bin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bin.FieldRemark) {
		fields = append(fields, bin.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BinMutation) ClearField(name string) error {
	switch name {
	case bin.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Bin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BinMutation) ResetField(name string) error {
	switch name {
	case bin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bin.FieldUUID:
		m.ResetUUID()
		return nil
	case bin.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case bin.FieldBrand:
		m.ResetBrand()
		return nil
	case bin.FieldSerial:
		m.ResetSerial()
		return nil
	case bin.FieldName:
		m.ResetName()
		return nil
	case bin.FieldOrdinal:
		m.ResetOrdinal()
		return nil
	case bin.FieldOpen:
		m.ResetOpen()
		return nil
	case bin.FieldEnable:
		m.ResetEnable()
		return nil
	case bin.FieldHealth:
		m.ResetHealth()
		return nil
	case bin.FieldBatteryExists:
		m.ResetBatteryExists()
		return nil
	case bin.FieldBatterySn:
		m.ResetBatterySn()
		return nil
	case bin.FieldVoltage:
		m.ResetVoltage()
		return nil
	case bin.FieldCurrent:
		m.ResetCurrent()
		return nil
	case bin.FieldSoc:
		m.ResetSoc()
		return nil
	case bin.FieldSoh:
		m.ResetSoh()
		return nil
	case bin.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Bin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BinMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cabinet != nil {
		edges = append(edges, bin.EdgeCabinet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BinMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bin.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcabinet {
		edges = append(edges, bin.EdgeCabinet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BinMutation) EdgeCleared(name string) bool {
	switch name {
	case bin.EdgeCabinet:
		return m.clearedcabinet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BinMutation) ClearEdge(name string) error {
	switch name {
	case bin.EdgeCabinet:
		m.ClearCabinet()
		return nil
	}
	return fmt.Errorf("unknown Bin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BinMutation) ResetEdge(name string) error {
	switch name {
	case bin.EdgeCabinet:
		m.ResetCabinet()
		return nil
	}
	return fmt.Errorf("unknown Bin edge %s", name)
}

// CabinetMutation represents an operation that mutates the Cabinet nodes in the graph.
type CabinetMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	online         *bool
	brand          *string
	serial         *string
	status         *cabinet.Status
	enable         *bool
	lng            *float64
	addlng         *float64
	lat            *float64
	addlat         *float64
	gsm            *float64
	addgsm         *float64
	voltage        *float64
	addvoltage     *float64
	current        *float64
	addcurrent     *float64
	temperature    *float64
	addtemperature *float64
	electricity    *float64
	addelectricity *float64
	clearedFields  map[string]struct{}
	bins           map[uint64]struct{}
	removedbins    map[uint64]struct{}
	clearedbins    bool
	done           bool
	oldValue       func(context.Context) (*Cabinet, error)
	predicates     []predicate.Cabinet
}

var _ ent.Mutation = (*CabinetMutation)(nil)

// cabinetOption allows management of the mutation configuration using functional options.
type cabinetOption func(*CabinetMutation)

// newCabinetMutation creates new mutation for the Cabinet entity.
func newCabinetMutation(c config, op Op, opts ...cabinetOption) *CabinetMutation {
	m := &CabinetMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetID sets the ID field of the mutation.
func withCabinetID(id uint64) cabinetOption {
	return func(m *CabinetMutation) {
		var (
			err   error
			once  sync.Once
			value *Cabinet
		)
		m.oldValue = func(ctx context.Context) (*Cabinet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cabinet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinet sets the old Cabinet of the mutation.
func withCabinet(node *Cabinet) cabinetOption {
	return func(m *CabinetMutation) {
		m.oldValue = func(context.Context) (*Cabinet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cabinet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOnline sets the "online" field.
func (m *CabinetMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *CabinetMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ResetOnline resets all changes to the "online" field.
func (m *CabinetMutation) ResetOnline() {
	m.online = nil
}

// SetBrand sets the "brand" field.
func (m *CabinetMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *CabinetMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *CabinetMutation) ResetBrand() {
	m.brand = nil
}

// SetSerial sets the "serial" field.
func (m *CabinetMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *CabinetMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *CabinetMutation) ResetSerial() {
	m.serial = nil
}

// SetStatus sets the "status" field.
func (m *CabinetMutation) SetStatus(c cabinet.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetMutation) Status() (r cabinet.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldStatus(ctx context.Context) (v cabinet.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetMutation) ResetStatus() {
	m.status = nil
}

// SetEnable sets the "enable" field.
func (m *CabinetMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *CabinetMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *CabinetMutation) ResetEnable() {
	m.enable = nil
}

// SetLng sets the "lng" field.
func (m *CabinetMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *CabinetMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLng(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *CabinetMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *CabinetMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLng clears the value of the "lng" field.
func (m *CabinetMutation) ClearLng() {
	m.lng = nil
	m.addlng = nil
	m.clearedFields[cabinet.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *CabinetMutation) LngCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *CabinetMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
	delete(m.clearedFields, cabinet.FieldLng)
}

// SetLat sets the "lat" field.
func (m *CabinetMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *CabinetMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *CabinetMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *CabinetMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *CabinetMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[cabinet.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *CabinetMutation) LatCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *CabinetMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, cabinet.FieldLat)
}

// SetGsm sets the "gsm" field.
func (m *CabinetMutation) SetGsm(f float64) {
	m.gsm = &f
	m.addgsm = nil
}

// Gsm returns the value of the "gsm" field in the mutation.
func (m *CabinetMutation) Gsm() (r float64, exists bool) {
	v := m.gsm
	if v == nil {
		return
	}
	return *v, true
}

// OldGsm returns the old "gsm" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldGsm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGsm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGsm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGsm: %w", err)
	}
	return oldValue.Gsm, nil
}

// AddGsm adds f to the "gsm" field.
func (m *CabinetMutation) AddGsm(f float64) {
	if m.addgsm != nil {
		*m.addgsm += f
	} else {
		m.addgsm = &f
	}
}

// AddedGsm returns the value that was added to the "gsm" field in this mutation.
func (m *CabinetMutation) AddedGsm() (r float64, exists bool) {
	v := m.addgsm
	if v == nil {
		return
	}
	return *v, true
}

// ClearGsm clears the value of the "gsm" field.
func (m *CabinetMutation) ClearGsm() {
	m.gsm = nil
	m.addgsm = nil
	m.clearedFields[cabinet.FieldGsm] = struct{}{}
}

// GsmCleared returns if the "gsm" field was cleared in this mutation.
func (m *CabinetMutation) GsmCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldGsm]
	return ok
}

// ResetGsm resets all changes to the "gsm" field.
func (m *CabinetMutation) ResetGsm() {
	m.gsm = nil
	m.addgsm = nil
	delete(m.clearedFields, cabinet.FieldGsm)
}

// SetVoltage sets the "voltage" field.
func (m *CabinetMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *CabinetMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldVoltage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *CabinetMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *CabinetMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ClearVoltage clears the value of the "voltage" field.
func (m *CabinetMutation) ClearVoltage() {
	m.voltage = nil
	m.addvoltage = nil
	m.clearedFields[cabinet.FieldVoltage] = struct{}{}
}

// VoltageCleared returns if the "voltage" field was cleared in this mutation.
func (m *CabinetMutation) VoltageCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldVoltage]
	return ok
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *CabinetMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
	delete(m.clearedFields, cabinet.FieldVoltage)
}

// SetCurrent sets the "current" field.
func (m *CabinetMutation) SetCurrent(f float64) {
	m.current = &f
	m.addcurrent = nil
}

// Current returns the value of the "current" field in the mutation.
func (m *CabinetMutation) Current() (r float64, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCurrent(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// AddCurrent adds f to the "current" field.
func (m *CabinetMutation) AddCurrent(f float64) {
	if m.addcurrent != nil {
		*m.addcurrent += f
	} else {
		m.addcurrent = &f
	}
}

// AddedCurrent returns the value that was added to the "current" field in this mutation.
func (m *CabinetMutation) AddedCurrent() (r float64, exists bool) {
	v := m.addcurrent
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrent clears the value of the "current" field.
func (m *CabinetMutation) ClearCurrent() {
	m.current = nil
	m.addcurrent = nil
	m.clearedFields[cabinet.FieldCurrent] = struct{}{}
}

// CurrentCleared returns if the "current" field was cleared in this mutation.
func (m *CabinetMutation) CurrentCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldCurrent]
	return ok
}

// ResetCurrent resets all changes to the "current" field.
func (m *CabinetMutation) ResetCurrent() {
	m.current = nil
	m.addcurrent = nil
	delete(m.clearedFields, cabinet.FieldCurrent)
}

// SetTemperature sets the "temperature" field.
func (m *CabinetMutation) SetTemperature(f float64) {
	m.temperature = &f
	m.addtemperature = nil
}

// Temperature returns the value of the "temperature" field in the mutation.
func (m *CabinetMutation) Temperature() (r float64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old "temperature" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldTemperature(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds f to the "temperature" field.
func (m *CabinetMutation) AddTemperature(f float64) {
	if m.addtemperature != nil {
		*m.addtemperature += f
	} else {
		m.addtemperature = &f
	}
}

// AddedTemperature returns the value that was added to the "temperature" field in this mutation.
func (m *CabinetMutation) AddedTemperature() (r float64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemperature clears the value of the "temperature" field.
func (m *CabinetMutation) ClearTemperature() {
	m.temperature = nil
	m.addtemperature = nil
	m.clearedFields[cabinet.FieldTemperature] = struct{}{}
}

// TemperatureCleared returns if the "temperature" field was cleared in this mutation.
func (m *CabinetMutation) TemperatureCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldTemperature]
	return ok
}

// ResetTemperature resets all changes to the "temperature" field.
func (m *CabinetMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
	delete(m.clearedFields, cabinet.FieldTemperature)
}

// SetElectricity sets the "electricity" field.
func (m *CabinetMutation) SetElectricity(f float64) {
	m.electricity = &f
	m.addelectricity = nil
}

// Electricity returns the value of the "electricity" field in the mutation.
func (m *CabinetMutation) Electricity() (r float64, exists bool) {
	v := m.electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricity returns the old "electricity" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricity: %w", err)
	}
	return oldValue.Electricity, nil
}

// AddElectricity adds f to the "electricity" field.
func (m *CabinetMutation) AddElectricity(f float64) {
	if m.addelectricity != nil {
		*m.addelectricity += f
	} else {
		m.addelectricity = &f
	}
}

// AddedElectricity returns the value that was added to the "electricity" field in this mutation.
func (m *CabinetMutation) AddedElectricity() (r float64, exists bool) {
	v := m.addelectricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearElectricity clears the value of the "electricity" field.
func (m *CabinetMutation) ClearElectricity() {
	m.electricity = nil
	m.addelectricity = nil
	m.clearedFields[cabinet.FieldElectricity] = struct{}{}
}

// ElectricityCleared returns if the "electricity" field was cleared in this mutation.
func (m *CabinetMutation) ElectricityCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldElectricity]
	return ok
}

// ResetElectricity resets all changes to the "electricity" field.
func (m *CabinetMutation) ResetElectricity() {
	m.electricity = nil
	m.addelectricity = nil
	delete(m.clearedFields, cabinet.FieldElectricity)
}

// AddBinIDs adds the "bins" edge to the Bin entity by ids.
func (m *CabinetMutation) AddBinIDs(ids ...uint64) {
	if m.bins == nil {
		m.bins = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bins[ids[i]] = struct{}{}
	}
}

// ClearBins clears the "bins" edge to the Bin entity.
func (m *CabinetMutation) ClearBins() {
	m.clearedbins = true
}

// BinsCleared reports if the "bins" edge to the Bin entity was cleared.
func (m *CabinetMutation) BinsCleared() bool {
	return m.clearedbins
}

// RemoveBinIDs removes the "bins" edge to the Bin entity by IDs.
func (m *CabinetMutation) RemoveBinIDs(ids ...uint64) {
	if m.removedbins == nil {
		m.removedbins = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bins, ids[i])
		m.removedbins[ids[i]] = struct{}{}
	}
}

// RemovedBins returns the removed IDs of the "bins" edge to the Bin entity.
func (m *CabinetMutation) RemovedBinsIDs() (ids []uint64) {
	for id := range m.removedbins {
		ids = append(ids, id)
	}
	return
}

// BinsIDs returns the "bins" edge IDs in the mutation.
func (m *CabinetMutation) BinsIDs() (ids []uint64) {
	for id := range m.bins {
		ids = append(ids, id)
	}
	return
}

// ResetBins resets all changes to the "bins" edge.
func (m *CabinetMutation) ResetBins() {
	m.bins = nil
	m.clearedbins = false
	m.removedbins = nil
}

// Where appends a list predicates to the CabinetMutation builder.
func (m *CabinetMutation) Where(ps ...predicate.Cabinet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CabinetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CabinetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cabinet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CabinetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CabinetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cabinet).
func (m *CabinetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, cabinet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinet.FieldUpdatedAt)
	}
	if m.online != nil {
		fields = append(fields, cabinet.FieldOnline)
	}
	if m.brand != nil {
		fields = append(fields, cabinet.FieldBrand)
	}
	if m.serial != nil {
		fields = append(fields, cabinet.FieldSerial)
	}
	if m.status != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.enable != nil {
		fields = append(fields, cabinet.FieldEnable)
	}
	if m.lng != nil {
		fields = append(fields, cabinet.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, cabinet.FieldLat)
	}
	if m.gsm != nil {
		fields = append(fields, cabinet.FieldGsm)
	}
	if m.voltage != nil {
		fields = append(fields, cabinet.FieldVoltage)
	}
	if m.current != nil {
		fields = append(fields, cabinet.FieldCurrent)
	}
	if m.temperature != nil {
		fields = append(fields, cabinet.FieldTemperature)
	}
	if m.electricity != nil {
		fields = append(fields, cabinet.FieldElectricity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.CreatedAt()
	case cabinet.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinet.FieldOnline:
		return m.Online()
	case cabinet.FieldBrand:
		return m.Brand()
	case cabinet.FieldSerial:
		return m.Serial()
	case cabinet.FieldStatus:
		return m.Status()
	case cabinet.FieldEnable:
		return m.Enable()
	case cabinet.FieldLng:
		return m.Lng()
	case cabinet.FieldLat:
		return m.Lat()
	case cabinet.FieldGsm:
		return m.Gsm()
	case cabinet.FieldVoltage:
		return m.Voltage()
	case cabinet.FieldCurrent:
		return m.Current()
	case cabinet.FieldTemperature:
		return m.Temperature()
	case cabinet.FieldElectricity:
		return m.Electricity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinet.FieldOnline:
		return m.OldOnline(ctx)
	case cabinet.FieldBrand:
		return m.OldBrand(ctx)
	case cabinet.FieldSerial:
		return m.OldSerial(ctx)
	case cabinet.FieldStatus:
		return m.OldStatus(ctx)
	case cabinet.FieldEnable:
		return m.OldEnable(ctx)
	case cabinet.FieldLng:
		return m.OldLng(ctx)
	case cabinet.FieldLat:
		return m.OldLat(ctx)
	case cabinet.FieldGsm:
		return m.OldGsm(ctx)
	case cabinet.FieldVoltage:
		return m.OldVoltage(ctx)
	case cabinet.FieldCurrent:
		return m.OldCurrent(ctx)
	case cabinet.FieldTemperature:
		return m.OldTemperature(ctx)
	case cabinet.FieldElectricity:
		return m.OldElectricity(ctx)
	}
	return nil, fmt.Errorf("unknown Cabinet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinet.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case cabinet.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case cabinet.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(cabinet.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinet.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case cabinet.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case cabinet.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case cabinet.FieldGsm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGsm(v)
		return nil
	case cabinet.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case cabinet.FieldCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case cabinet.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case cabinet.FieldElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricity(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, cabinet.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, cabinet.FieldLat)
	}
	if m.addgsm != nil {
		fields = append(fields, cabinet.FieldGsm)
	}
	if m.addvoltage != nil {
		fields = append(fields, cabinet.FieldVoltage)
	}
	if m.addcurrent != nil {
		fields = append(fields, cabinet.FieldCurrent)
	}
	if m.addtemperature != nil {
		fields = append(fields, cabinet.FieldTemperature)
	}
	if m.addelectricity != nil {
		fields = append(fields, cabinet.FieldElectricity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldLng:
		return m.AddedLng()
	case cabinet.FieldLat:
		return m.AddedLat()
	case cabinet.FieldGsm:
		return m.AddedGsm()
	case cabinet.FieldVoltage:
		return m.AddedVoltage()
	case cabinet.FieldCurrent:
		return m.AddedCurrent()
	case cabinet.FieldTemperature:
		return m.AddedTemperature()
	case cabinet.FieldElectricity:
		return m.AddedElectricity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case cabinet.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case cabinet.FieldGsm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGsm(v)
		return nil
	case cabinet.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case cabinet.FieldCurrent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrent(v)
		return nil
	case cabinet.FieldTemperature:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case cabinet.FieldElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectricity(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinet.FieldLng) {
		fields = append(fields, cabinet.FieldLng)
	}
	if m.FieldCleared(cabinet.FieldLat) {
		fields = append(fields, cabinet.FieldLat)
	}
	if m.FieldCleared(cabinet.FieldGsm) {
		fields = append(fields, cabinet.FieldGsm)
	}
	if m.FieldCleared(cabinet.FieldVoltage) {
		fields = append(fields, cabinet.FieldVoltage)
	}
	if m.FieldCleared(cabinet.FieldCurrent) {
		fields = append(fields, cabinet.FieldCurrent)
	}
	if m.FieldCleared(cabinet.FieldTemperature) {
		fields = append(fields, cabinet.FieldTemperature)
	}
	if m.FieldCleared(cabinet.FieldElectricity) {
		fields = append(fields, cabinet.FieldElectricity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetMutation) ClearField(name string) error {
	switch name {
	case cabinet.FieldLng:
		m.ClearLng()
		return nil
	case cabinet.FieldLat:
		m.ClearLat()
		return nil
	case cabinet.FieldGsm:
		m.ClearGsm()
		return nil
	case cabinet.FieldVoltage:
		m.ClearVoltage()
		return nil
	case cabinet.FieldCurrent:
		m.ClearCurrent()
		return nil
	case cabinet.FieldTemperature:
		m.ClearTemperature()
		return nil
	case cabinet.FieldElectricity:
		m.ClearElectricity()
		return nil
	}
	return fmt.Errorf("unknown Cabinet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetMutation) ResetField(name string) error {
	switch name {
	case cabinet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinet.FieldOnline:
		m.ResetOnline()
		return nil
	case cabinet.FieldBrand:
		m.ResetBrand()
		return nil
	case cabinet.FieldSerial:
		m.ResetSerial()
		return nil
	case cabinet.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinet.FieldEnable:
		m.ResetEnable()
		return nil
	case cabinet.FieldLng:
		m.ResetLng()
		return nil
	case cabinet.FieldLat:
		m.ResetLat()
		return nil
	case cabinet.FieldGsm:
		m.ResetGsm()
		return nil
	case cabinet.FieldVoltage:
		m.ResetVoltage()
		return nil
	case cabinet.FieldCurrent:
		m.ResetCurrent()
		return nil
	case cabinet.FieldTemperature:
		m.ResetTemperature()
		return nil
	case cabinet.FieldElectricity:
		m.ResetElectricity()
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bins != nil {
		edges = append(edges, cabinet.EdgeBins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeBins:
		ids := make([]ent.Value, 0, len(m.bins))
		for id := range m.bins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbins != nil {
		edges = append(edges, cabinet.EdgeBins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeBins:
		ids := make([]ent.Value, 0, len(m.removedbins))
		for id := range m.removedbins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbins {
		edges = append(edges, cabinet.EdgeBins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinet.EdgeBins:
		return m.clearedbins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Cabinet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetMutation) ResetEdge(name string) error {
	switch name {
	case cabinet.EdgeBins:
		m.ResetBins()
		return nil
	}
	return fmt.Errorf("unknown Cabinet edge %s", name)
}

// ConsoleMutation represents an operation that mutates the Console nodes in the graph.
type ConsoleMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	uuid           *uuid.UUID
	_type          *console.Type
	user_id        *string
	user_type      *model.UserType
	step           *model.ExchangeStep
	status         *console.Status
	before_bin     **types.BinInfo
	after_bin      **types.BinInfo
	message        *string
	startAt        *time.Time
	stopAt         *time.Time
	clearedFields  map[string]struct{}
	cabinet        *uint64
	clearedcabinet bool
	bin            *uint64
	clearedbin     bool
	done           bool
	oldValue       func(context.Context) (*Console, error)
	predicates     []predicate.Console
}

var _ ent.Mutation = (*ConsoleMutation)(nil)

// consoleOption allows management of the mutation configuration using functional options.
type consoleOption func(*ConsoleMutation)

// newConsoleMutation creates new mutation for the Console entity.
func newConsoleMutation(c config, op Op, opts ...consoleOption) *ConsoleMutation {
	m := &ConsoleMutation{
		config:        c,
		op:            op,
		typ:           TypeConsole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsoleID sets the ID field of the mutation.
func withConsoleID(id uint64) consoleOption {
	return func(m *ConsoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Console
		)
		m.oldValue = func(ctx context.Context) (*Console, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Console.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsole sets the old Console of the mutation.
func withConsole(node *Console) consoleOption {
	return func(m *ConsoleMutation) {
		m.oldValue = func(context.Context) (*Console, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsoleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsoleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Console.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCabinetID sets the "cabinet_id" field.
func (m *ConsoleMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *ConsoleMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *ConsoleMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetBinID sets the "bin_id" field.
func (m *ConsoleMutation) SetBinID(u uint64) {
	m.bin = &u
}

// BinID returns the value of the "bin_id" field in the mutation.
func (m *ConsoleMutation) BinID() (r uint64, exists bool) {
	v := m.bin
	if v == nil {
		return
	}
	return *v, true
}

// OldBinID returns the old "bin_id" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldBinID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinID: %w", err)
	}
	return oldValue.BinID, nil
}

// ResetBinID resets all changes to the "bin_id" field.
func (m *ConsoleMutation) ResetBinID() {
	m.bin = nil
}

// SetUUID sets the "uuid" field.
func (m *ConsoleMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ConsoleMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ConsoleMutation) ResetUUID() {
	m.uuid = nil
}

// SetType sets the "type" field.
func (m *ConsoleMutation) SetType(c console.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConsoleMutation) GetType() (r console.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldType(ctx context.Context) (v console.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ConsoleMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *ConsoleMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConsoleMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConsoleMutation) ResetUserID() {
	m.user_id = nil
}

// SetUserType sets the "user_type" field.
func (m *ConsoleMutation) SetUserType(mt model.UserType) {
	m.user_type = &mt
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *ConsoleMutation) UserType() (r model.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldUserType(ctx context.Context) (v *model.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ClearUserType clears the value of the "user_type" field.
func (m *ConsoleMutation) ClearUserType() {
	m.user_type = nil
	m.clearedFields[console.FieldUserType] = struct{}{}
}

// UserTypeCleared returns if the "user_type" field was cleared in this mutation.
func (m *ConsoleMutation) UserTypeCleared() bool {
	_, ok := m.clearedFields[console.FieldUserType]
	return ok
}

// ResetUserType resets all changes to the "user_type" field.
func (m *ConsoleMutation) ResetUserType() {
	m.user_type = nil
	delete(m.clearedFields, console.FieldUserType)
}

// SetStep sets the "step" field.
func (m *ConsoleMutation) SetStep(ms model.ExchangeStep) {
	m.step = &ms
}

// Step returns the value of the "step" field in the mutation.
func (m *ConsoleMutation) Step() (r model.ExchangeStep, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStep returns the old "step" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldStep(ctx context.Context) (v *model.ExchangeStep, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStep: %w", err)
	}
	return oldValue.Step, nil
}

// ClearStep clears the value of the "step" field.
func (m *ConsoleMutation) ClearStep() {
	m.step = nil
	m.clearedFields[console.FieldStep] = struct{}{}
}

// StepCleared returns if the "step" field was cleared in this mutation.
func (m *ConsoleMutation) StepCleared() bool {
	_, ok := m.clearedFields[console.FieldStep]
	return ok
}

// ResetStep resets all changes to the "step" field.
func (m *ConsoleMutation) ResetStep() {
	m.step = nil
	delete(m.clearedFields, console.FieldStep)
}

// SetStatus sets the "status" field.
func (m *ConsoleMutation) SetStatus(c console.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ConsoleMutation) Status() (r console.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldStatus(ctx context.Context) (v console.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConsoleMutation) ResetStatus() {
	m.status = nil
}

// SetBeforeBin sets the "before_bin" field.
func (m *ConsoleMutation) SetBeforeBin(ti *types.BinInfo) {
	m.before_bin = &ti
}

// BeforeBin returns the value of the "before_bin" field in the mutation.
func (m *ConsoleMutation) BeforeBin() (r *types.BinInfo, exists bool) {
	v := m.before_bin
	if v == nil {
		return
	}
	return *v, true
}

// OldBeforeBin returns the old "before_bin" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldBeforeBin(ctx context.Context) (v *types.BinInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeforeBin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeforeBin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeforeBin: %w", err)
	}
	return oldValue.BeforeBin, nil
}

// ClearBeforeBin clears the value of the "before_bin" field.
func (m *ConsoleMutation) ClearBeforeBin() {
	m.before_bin = nil
	m.clearedFields[console.FieldBeforeBin] = struct{}{}
}

// BeforeBinCleared returns if the "before_bin" field was cleared in this mutation.
func (m *ConsoleMutation) BeforeBinCleared() bool {
	_, ok := m.clearedFields[console.FieldBeforeBin]
	return ok
}

// ResetBeforeBin resets all changes to the "before_bin" field.
func (m *ConsoleMutation) ResetBeforeBin() {
	m.before_bin = nil
	delete(m.clearedFields, console.FieldBeforeBin)
}

// SetAfterBin sets the "after_bin" field.
func (m *ConsoleMutation) SetAfterBin(ti *types.BinInfo) {
	m.after_bin = &ti
}

// AfterBin returns the value of the "after_bin" field in the mutation.
func (m *ConsoleMutation) AfterBin() (r *types.BinInfo, exists bool) {
	v := m.after_bin
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterBin returns the old "after_bin" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldAfterBin(ctx context.Context) (v *types.BinInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterBin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterBin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterBin: %w", err)
	}
	return oldValue.AfterBin, nil
}

// ClearAfterBin clears the value of the "after_bin" field.
func (m *ConsoleMutation) ClearAfterBin() {
	m.after_bin = nil
	m.clearedFields[console.FieldAfterBin] = struct{}{}
}

// AfterBinCleared returns if the "after_bin" field was cleared in this mutation.
func (m *ConsoleMutation) AfterBinCleared() bool {
	_, ok := m.clearedFields[console.FieldAfterBin]
	return ok
}

// ResetAfterBin resets all changes to the "after_bin" field.
func (m *ConsoleMutation) ResetAfterBin() {
	m.after_bin = nil
	delete(m.clearedFields, console.FieldAfterBin)
}

// SetMessage sets the "message" field.
func (m *ConsoleMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ConsoleMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *ConsoleMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[console.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *ConsoleMutation) MessageCleared() bool {
	_, ok := m.clearedFields[console.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *ConsoleMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, console.FieldMessage)
}

// SetStartAt sets the "startAt" field.
func (m *ConsoleMutation) SetStartAt(t time.Time) {
	m.startAt = &t
}

// StartAt returns the value of the "startAt" field in the mutation.
func (m *ConsoleMutation) StartAt() (r time.Time, exists bool) {
	v := m.startAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "startAt" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "startAt" field.
func (m *ConsoleMutation) ResetStartAt() {
	m.startAt = nil
}

// SetStopAt sets the "stopAt" field.
func (m *ConsoleMutation) SetStopAt(t time.Time) {
	m.stopAt = &t
}

// StopAt returns the value of the "stopAt" field in the mutation.
func (m *ConsoleMutation) StopAt() (r time.Time, exists bool) {
	v := m.stopAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStopAt returns the old "stopAt" field's value of the Console entity.
// If the Console object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsoleMutation) OldStopAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopAt: %w", err)
	}
	return oldValue.StopAt, nil
}

// ClearStopAt clears the value of the "stopAt" field.
func (m *ConsoleMutation) ClearStopAt() {
	m.stopAt = nil
	m.clearedFields[console.FieldStopAt] = struct{}{}
}

// StopAtCleared returns if the "stopAt" field was cleared in this mutation.
func (m *ConsoleMutation) StopAtCleared() bool {
	_, ok := m.clearedFields[console.FieldStopAt]
	return ok
}

// ResetStopAt resets all changes to the "stopAt" field.
func (m *ConsoleMutation) ResetStopAt() {
	m.stopAt = nil
	delete(m.clearedFields, console.FieldStopAt)
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *ConsoleMutation) ClearCabinet() {
	m.clearedcabinet = true
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *ConsoleMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *ConsoleMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *ConsoleMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearBin clears the "bin" edge to the Bin entity.
func (m *ConsoleMutation) ClearBin() {
	m.clearedbin = true
}

// BinCleared reports if the "bin" edge to the Bin entity was cleared.
func (m *ConsoleMutation) BinCleared() bool {
	return m.clearedbin
}

// BinIDs returns the "bin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BinID instead. It exists only for internal usage by the builders.
func (m *ConsoleMutation) BinIDs() (ids []uint64) {
	if id := m.bin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBin resets all changes to the "bin" edge.
func (m *ConsoleMutation) ResetBin() {
	m.bin = nil
	m.clearedbin = false
}

// Where appends a list predicates to the ConsoleMutation builder.
func (m *ConsoleMutation) Where(ps ...predicate.Console) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Console, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Console).
func (m *ConsoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsoleMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.cabinet != nil {
		fields = append(fields, console.FieldCabinetID)
	}
	if m.bin != nil {
		fields = append(fields, console.FieldBinID)
	}
	if m.uuid != nil {
		fields = append(fields, console.FieldUUID)
	}
	if m._type != nil {
		fields = append(fields, console.FieldType)
	}
	if m.user_id != nil {
		fields = append(fields, console.FieldUserID)
	}
	if m.user_type != nil {
		fields = append(fields, console.FieldUserType)
	}
	if m.step != nil {
		fields = append(fields, console.FieldStep)
	}
	if m.status != nil {
		fields = append(fields, console.FieldStatus)
	}
	if m.before_bin != nil {
		fields = append(fields, console.FieldBeforeBin)
	}
	if m.after_bin != nil {
		fields = append(fields, console.FieldAfterBin)
	}
	if m.message != nil {
		fields = append(fields, console.FieldMessage)
	}
	if m.startAt != nil {
		fields = append(fields, console.FieldStartAt)
	}
	if m.stopAt != nil {
		fields = append(fields, console.FieldStopAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case console.FieldCabinetID:
		return m.CabinetID()
	case console.FieldBinID:
		return m.BinID()
	case console.FieldUUID:
		return m.UUID()
	case console.FieldType:
		return m.GetType()
	case console.FieldUserID:
		return m.UserID()
	case console.FieldUserType:
		return m.UserType()
	case console.FieldStep:
		return m.Step()
	case console.FieldStatus:
		return m.Status()
	case console.FieldBeforeBin:
		return m.BeforeBin()
	case console.FieldAfterBin:
		return m.AfterBin()
	case console.FieldMessage:
		return m.Message()
	case console.FieldStartAt:
		return m.StartAt()
	case console.FieldStopAt:
		return m.StopAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case console.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case console.FieldBinID:
		return m.OldBinID(ctx)
	case console.FieldUUID:
		return m.OldUUID(ctx)
	case console.FieldType:
		return m.OldType(ctx)
	case console.FieldUserID:
		return m.OldUserID(ctx)
	case console.FieldUserType:
		return m.OldUserType(ctx)
	case console.FieldStep:
		return m.OldStep(ctx)
	case console.FieldStatus:
		return m.OldStatus(ctx)
	case console.FieldBeforeBin:
		return m.OldBeforeBin(ctx)
	case console.FieldAfterBin:
		return m.OldAfterBin(ctx)
	case console.FieldMessage:
		return m.OldMessage(ctx)
	case console.FieldStartAt:
		return m.OldStartAt(ctx)
	case console.FieldStopAt:
		return m.OldStopAt(ctx)
	}
	return nil, fmt.Errorf("unknown Console field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case console.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case console.FieldBinID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinID(v)
		return nil
	case console.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case console.FieldType:
		v, ok := value.(console.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case console.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case console.FieldUserType:
		v, ok := value.(model.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case console.FieldStep:
		v, ok := value.(model.ExchangeStep)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStep(v)
		return nil
	case console.FieldStatus:
		v, ok := value.(console.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case console.FieldBeforeBin:
		v, ok := value.(*types.BinInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeforeBin(v)
		return nil
	case console.FieldAfterBin:
		v, ok := value.(*types.BinInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterBin(v)
		return nil
	case console.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case console.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case console.FieldStopAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopAt(v)
		return nil
	}
	return fmt.Errorf("unknown Console field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Console numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(console.FieldUserType) {
		fields = append(fields, console.FieldUserType)
	}
	if m.FieldCleared(console.FieldStep) {
		fields = append(fields, console.FieldStep)
	}
	if m.FieldCleared(console.FieldBeforeBin) {
		fields = append(fields, console.FieldBeforeBin)
	}
	if m.FieldCleared(console.FieldAfterBin) {
		fields = append(fields, console.FieldAfterBin)
	}
	if m.FieldCleared(console.FieldMessage) {
		fields = append(fields, console.FieldMessage)
	}
	if m.FieldCleared(console.FieldStopAt) {
		fields = append(fields, console.FieldStopAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsoleMutation) ClearField(name string) error {
	switch name {
	case console.FieldUserType:
		m.ClearUserType()
		return nil
	case console.FieldStep:
		m.ClearStep()
		return nil
	case console.FieldBeforeBin:
		m.ClearBeforeBin()
		return nil
	case console.FieldAfterBin:
		m.ClearAfterBin()
		return nil
	case console.FieldMessage:
		m.ClearMessage()
		return nil
	case console.FieldStopAt:
		m.ClearStopAt()
		return nil
	}
	return fmt.Errorf("unknown Console nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsoleMutation) ResetField(name string) error {
	switch name {
	case console.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case console.FieldBinID:
		m.ResetBinID()
		return nil
	case console.FieldUUID:
		m.ResetUUID()
		return nil
	case console.FieldType:
		m.ResetType()
		return nil
	case console.FieldUserID:
		m.ResetUserID()
		return nil
	case console.FieldUserType:
		m.ResetUserType()
		return nil
	case console.FieldStep:
		m.ResetStep()
		return nil
	case console.FieldStatus:
		m.ResetStatus()
		return nil
	case console.FieldBeforeBin:
		m.ResetBeforeBin()
		return nil
	case console.FieldAfterBin:
		m.ResetAfterBin()
		return nil
	case console.FieldMessage:
		m.ResetMessage()
		return nil
	case console.FieldStartAt:
		m.ResetStartAt()
		return nil
	case console.FieldStopAt:
		m.ResetStopAt()
		return nil
	}
	return fmt.Errorf("unknown Console field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cabinet != nil {
		edges = append(edges, console.EdgeCabinet)
	}
	if m.bin != nil {
		edges = append(edges, console.EdgeBin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case console.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case console.EdgeBin:
		if id := m.bin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcabinet {
		edges = append(edges, console.EdgeCabinet)
	}
	if m.clearedbin {
		edges = append(edges, console.EdgeBin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsoleMutation) EdgeCleared(name string) bool {
	switch name {
	case console.EdgeCabinet:
		return m.clearedcabinet
	case console.EdgeBin:
		return m.clearedbin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsoleMutation) ClearEdge(name string) error {
	switch name {
	case console.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case console.EdgeBin:
		m.ClearBin()
		return nil
	}
	return fmt.Errorf("unknown Console unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsoleMutation) ResetEdge(name string) error {
	switch name {
	case console.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case console.EdgeBin:
		m.ResetBin()
		return nil
	}
	return fmt.Errorf("unknown Console edge %s", name)
}

// ScanMutation represents an operation that mutates the Scan nodes in the graph.
type ScanMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *string
	user_type     *model.UserType
	serial        *string
	data          **model.ExchangeUsableResponse
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Scan, error)
	predicates    []predicate.Scan
}

var _ ent.Mutation = (*ScanMutation)(nil)

// scanOption allows management of the mutation configuration using functional options.
type scanOption func(*ScanMutation)

// newScanMutation creates new mutation for the Scan entity.
func newScanMutation(c config, op Op, opts ...scanOption) *ScanMutation {
	m := &ScanMutation{
		config:        c,
		op:            op,
		typ:           TypeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanID sets the ID field of the mutation.
func withScanID(id uuid.UUID) scanOption {
	return func(m *ScanMutation) {
		var (
			err   error
			once  sync.Once
			value *Scan
		)
		m.oldValue = func(ctx context.Context) (*Scan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScan sets the old Scan of the mutation.
func withScan(node *Scan) scanOption {
	return func(m *ScanMutation) {
		m.oldValue = func(context.Context) (*Scan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scan entities.
func (m *ScanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ScanMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ScanMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ScanMutation) ResetUserID() {
	m.user_id = nil
}

// SetUserType sets the "user_type" field.
func (m *ScanMutation) SetUserType(mt model.UserType) {
	m.user_type = &mt
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *ScanMutation) UserType() (r model.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldUserType(ctx context.Context) (v *model.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ClearUserType clears the value of the "user_type" field.
func (m *ScanMutation) ClearUserType() {
	m.user_type = nil
	m.clearedFields[scan.FieldUserType] = struct{}{}
}

// UserTypeCleared returns if the "user_type" field was cleared in this mutation.
func (m *ScanMutation) UserTypeCleared() bool {
	_, ok := m.clearedFields[scan.FieldUserType]
	return ok
}

// ResetUserType resets all changes to the "user_type" field.
func (m *ScanMutation) ResetUserType() {
	m.user_type = nil
	delete(m.clearedFields, scan.FieldUserType)
}

// SetSerial sets the "serial" field.
func (m *ScanMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ScanMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ScanMutation) ResetSerial() {
	m.serial = nil
}

// SetData sets the "data" field.
func (m *ScanMutation) SetData(mur *model.ExchangeUsableResponse) {
	m.data = &mur
}

// Data returns the value of the "data" field in the mutation.
func (m *ScanMutation) Data() (r *model.ExchangeUsableResponse, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldData(ctx context.Context) (v *model.ExchangeUsableResponse, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *ScanMutation) ClearData() {
	m.data = nil
	m.clearedFields[scan.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *ScanMutation) DataCleared() bool {
	_, ok := m.clearedFields[scan.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *ScanMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, scan.FieldData)
}

// Where appends a list predicates to the ScanMutation builder.
func (m *ScanMutation) Where(ps ...predicate.Scan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scan).
func (m *ScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, scan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scan.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, scan.FieldUserID)
	}
	if m.user_type != nil {
		fields = append(fields, scan.FieldUserType)
	}
	if m.serial != nil {
		fields = append(fields, scan.FieldSerial)
	}
	if m.data != nil {
		fields = append(fields, scan.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldCreatedAt:
		return m.CreatedAt()
	case scan.FieldUpdatedAt:
		return m.UpdatedAt()
	case scan.FieldUserID:
		return m.UserID()
	case scan.FieldUserType:
		return m.UserType()
	case scan.FieldSerial:
		return m.Serial()
	case scan.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case scan.FieldUserID:
		return m.OldUserID(ctx)
	case scan.FieldUserType:
		return m.OldUserType(ctx)
	case scan.FieldSerial:
		return m.OldSerial(ctx)
	case scan.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Scan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case scan.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case scan.FieldUserType:
		v, ok := value.(model.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case scan.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case scan.FieldData:
		v, ok := value.(*model.ExchangeUsableResponse)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scan.FieldUserType) {
		fields = append(fields, scan.FieldUserType)
	}
	if m.FieldCleared(scan.FieldData) {
		fields = append(fields, scan.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanMutation) ClearField(name string) error {
	switch name {
	case scan.FieldUserType:
		m.ClearUserType()
		return nil
	case scan.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Scan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanMutation) ResetField(name string) error {
	switch name {
	case scan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case scan.FieldUserID:
		m.ResetUserID()
		return nil
	case scan.FieldUserType:
		m.ResetUserType()
		return nil
	case scan.FieldSerial:
		m.ResetSerial()
		return nil
	case scan.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Scan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Scan edge %s", name)
}
